# Проверка лексикографической упорядоченности двух строк

- **Студент**: Белов Егор Алексеевич, группа 3823Б1ПР2
- **Технология**: SEQ | MPI
- **Вариант**: 26

## 1. Введение
Существует потребность в хранении и обработке коллекций текстовых предложений, хранимых в строках. Для решения этой проблемы можно применить всё те же алгоритмы и структуры данных, что и для хранения чисел. Очевидно, что в таком случае для некоторых алгоритмов может потребоваться определение упорядоченности строк. 

Эту проблему можно решить через определение лексикографичесой упорядоченности двух строк.

Наша задачу решить эту проблему с использованием параллельного программирования.

## 2. Постановка задачи
Даны две строки с количеством слов n1 и n2, содержащие предложения.

Требуется определить лексикографическую упорядоченность двух строк

Тип входных данных:
```cpp
using InType = std::tuple<std::string, std::string>;
```
Тип выходных данных:
```cpp
using OutType = bool;
```
Ограничения:
- Предложением считается перечеслением слов через пробелы.
- Предложение не содержит следующие знаки: ',', '.', '!', ';', '?' и прочее.

## 3. Базовый алгоритм (Sequential)
Cтроки проверяются на лексикографическую упорядоченность между собой следующим алгоритмом:
```cpp
  for (; iter1 != first.end() && iter2 != second.end(); iter1++, iter2++) {
    if (*iter1 < *iter2) {
      ans = true;
      flag = true;
      break;
    } else if (*iter1 != *iter2) {
      ans = false;
      flag = true;
      break;
    }
  }
```
То есть происходит лексикографическая проверка всех пар слов из двух строк по очереди. Проверка прекращается при нахождении не равных слов, и записывается ответ.

Если ответ не был найден при просмотре пар слов, то результат находится через сравнение размеров строк: 
```cpp
  if (flag == true) {
    GetOutput() = ans;
  } else {
    GetOutput() = (iter1 == first.end()) && (iter2 != second.end());
  }
```

## 4. Схема распараллеливания
### Краткое описание
1. Возьмём первые n слов из каждой строки, где n это миниимум из двух длин.
2. Разделим каждую строку на **chunk**, который возьмёт каждый процесс.
3. Каждый процесс находит **index**, где нарушается равенство слов, и запоминает лексикографический порядок **cmp_flag** между двумя словами в этом месте.
4. Результаты всех проверок на процессах собираются в один массив через **MPI_Gather()**.
5. Среди всех результатов находится минимальный **index** и соответствующий **cmp_flag**.
6. Выбранный результат анализируется, и записывается ответ.
### Алгоритм нахождения первого неравенства пары слов из двух строк
```cpp
ChunkAns ChunkCheck(const std::vector<std::string> &first, const std::vector<std::string> &second, int begin, int end) {
  ChunkAns ans{.index = -1, .cmp_flag = 0};
  for (int i = begin; i < end; i++) {
    if (first[i] < second[i]) {
      ans = {.index = i, .cmp_flag = -1};
      return ans;
    }
    if (first[i] > second[i]) {
      ans = {.index = i, .cmp_flag = 1};
      return ans;
    }
  }
  return ans;
}
```
### Алгоритм распределения кусочков по процессам
```cpp
  int chunk = CeilDiv(n, mpi_size);
  int begin = rank * chunk;
  int end = std::min(n, begin + chunk);
```
### Алгоритм распределения строки по процессам
```cpp
void BcastVectorOfStrings(std::vector<std::string> &vec, int n, MPI_Comm comm) {
  int rank = 0;
  MPI_Comm_rank(comm, &rank);

  if (rank != 0) {
    vec.resize(n);
  }

  for (int i = 0; i < n; i++) {
    int len = 0;
    if (rank == 0) {
      len = static_cast<int>(vec[i].size());
    }

    MPI_Bcast(&len, 1, MPI_INT, 0, comm);

    if (rank != 0) {
      vec[i].resize(len);
    }

    MPI_Bcast(vec[i].data(), len, MPI_CHAR, 0, comm);
  }
}
```
### Cхема параллельной работы алгоритма
1. Каждый процесс определяет количество процессов и свой ранг и записывает соответственно в переменные **mpi_size** и **rank**.
2. Нулевой процесс получает на вход из **GetProccesedInput()** две строки, определяет их размеры и записывает всё соответственно в переменные **first**, **second**, **n1**, **n2**.
3. Нулевой процесс распределяет через **MPI_Bcast()** на все процессы размеры строк **n1**, **n2**, а затем находится на всех процессах **n** - минимум из двух размеров.
4. Нулевой процесс распределяет через **BcastVectorOfStrings()** на все процессы обе строки **first** и **second**.
5. Каждый процесс вычисляет, какие части строк необходимо ему проверить через переменные **chunk**, **begin**, **end**.
6. Каждый процесс находит место в своей части, где слова не равны, через **ChunkCheck()** и записывает свой результат в **local_ans**.
7. С каждого процесса собираются их **local_ans** через **MPI_Gather()** в массив **results** на нулевом процессе.
8. Нулевой процесс вычисляет финальный результат и записывает его в **result**.
9. Нулевой процесс распределяет через **MPI_Bcast()** на все процессы **result**.
10. Каждый процесс записывает результат проверки в **GetOutput()**.
## 5. Детали реализации
|          Файл          |                 Назначение                  |
|------------------------|---------------------------------------------|
| `common.hpp`           | Определение входных, выходных типов задачи и тип тестов |
| `ops_seq.hpp/.cpp`     |         Последовательная реализаци  |
| `ops_mpi.hpp/.cpp`     |                MPI-реализация         |
| `functional/main.cpp`  |             Функциональные тесты          |
| `performance/main.cpp` |       Тесты производительности       |
## 6. Экспериментальная среда
|  Компонент |               Значение                       |
|------------|----------------------------------------------|
|     CPU    |           Apple M1                 |
|     RAM    |                 8 GB                       |
|     ОС     | OS: Ubuntu 24.04 (DevContainer / macOs 26.1) |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release     |
|     MPI    |        mpirun (Open MPI) 4.1.6            |
## 7. Результаты и обсуждение
### 7.1 Корректность
Для функциональных тестов: 4 .txt файла, содержащие два предложения и флаг для лексикографической упорядоченности.

Тесты были подобраны для проверок всех уникальных случаев работы алгоритма. Все тесты прошли проверку на SEQ и MPI реализации.
### 7.2 Производительность
Для тестов производительности: генерируется для каждого предложения 4000 одинаковых слов, алгоритм проверяет каждое слово в предложении.
| Mode        | Count | Time, s  | Speedup | Efficiency |
|-------------|-------|----------|---------|------------|
| seq         | 1     | 0,092450 | 1.00    | N/A        |
| mpi         | 2     | 0.057422 | 1,61    | 88.35%     |
| mpi         | 4     | 0.029537 | 3,13    | 78.32%     |
## 8. Заключение
В ходе выполнения работы удалось реализовать алгоритм проверки лексикографической упорядоченности двух строк, распараллелить его при помощи MPI и увидеть эффективность работы параллельного алгоритма.
## 9. Источники
1. Сысоев А. В. Курс лекций по параллельному программированию
2. Документация Open MPI     https://www.open-mpi.org/doc/
3. Microsoft Функции MPI     https://learn.microsoft.com/ru-ru/message-passing-interface/mpi-functions