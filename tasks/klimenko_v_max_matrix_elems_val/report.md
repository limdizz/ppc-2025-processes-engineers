Отчёт по задаче: "Максимальное значение элементов матрицы"
Вариант: №13
Выполнил студент группы 3823Б1ПР2: Клименко Владислав Сергеевич
Работу проверили: преподаватель Нестеров Александр Юрьевич и преподаватель Оболенский Арсений Андреевич

Введение
В данной работе был реализован алгоритм вычисления максимального значения элементов квадратной матрицы. Реализация происходила при помощи двух технологий: SEQ (последовательная) и MPI (параллельная). Цель - ускорение вычислений за счёт распределения строк матрицы между процессами и параллельного вычисления локальных максимумов.

Постановка задачи и формальное описание
Дана квадратная матрица размера n * n, элементами которой являются целые числа. Требуется найти наибольший элемент среди всех элементов матрицы.
Формальное описание: пусть задана матрица A = {a_ij}, i,j = 0...n-1. Необходимо вычислить z = max(a_ij).
Пример
Для матрицы (11 22 34
             34 15 62
             72 81 94) 
наибольший элемент 94.

Реализация разделена на модули
ops_seq.hpp и ops_seq.cpp — реализация последовательного алгоритма.
ops_mpi.hpp и ops_mpi.cpp — реализация параллельного алгоритма.
common.hpp — общее определение типов входных/выходных данных.

Описание последовательной версии
В последовательной реализации алгоритм последовательно проходит по всем элементам матрицы и запоминает наибольшее значение.
Этот вариант реализован в классе KlimenkoVMaxMatrixElemsValSEQ.

Описание параллельной версии
В параллельной реализации матрица делится по строкам между процессами MPI. Каждый процесс получает свой набор строк, вычисляет локальный максимум и передаёт его на процесс 0 с помощью MPI_Reduce. Процесс с рангом 0 получает итоговый максимум и сохраняет результат.
Этот вариант реализован в классе KlimenkoVMaxMatrixElemsValMPI.

Тестирования разделены на модули
functional/main.cpp — функциональные тесты
performance/main.cpp — производительные тесты

Функциональное тестирование
В тестах проверяется корректность работы обеих реализаций на матрицах небольшого размера (3×3, 5×5, 7×7). Значения элементов генерируются последовательно, и это позволяет точно предсказать ожидаемый результат. Тест автоматически запускает как последовательную, так и MPI-реализацию и сверяет результаты с ожидаемым значением.

Тестирование производительности
Для каждой реализации предусмотрено по два теста:

test_pipeline_run — тест, подразумевающий ручной запуск ValidationImpl, PreProcessingImpl, RunImpl,PostProcessingImpl.
test_task_run — тест с замером времени выполнения полной задачи.