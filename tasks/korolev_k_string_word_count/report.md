# Подсчёт количества слов в строке Королёв Кузьма

- Student: Королёв Кузьма, group 3823Б1ПР2  
- Technology: SEQ | MPI  
- Variant: Подсчёт количества слов в строке  

## 1. Introduction
Разработка однопоточного (SEQ) и параллельного (MPI) алгоритмов подсчёта количества слов в строке.  
Цель – ускорение обработки длинных строк за счёт распределения вычислений между несколькими процессами и корректного подсчёта слов в текстах, содержащих пробелы, табуляции, переносы строк, Unicode-символы и emoji.

## 2. Problem Statement
Для заданной строки необходимо определить количество слов.  
Под словом понимается максимальная последовательность непробельных символов. Пустые символы — любые, удовлетворяющие `isspace`.

**Вход:** строка произвольной длины (ASCII + Unicode).  
**Выход:** целое число — количество слов в строке.  
**Ограничения:** время работы <1 секунды в functional тестах.

Примеры:
- `"hello world"` → 2  
- `"\t tabs\tand  spaces \n mix"` → 4  
- `"русский  текст  да"` → 3  

## 3. Baseline Algorithm (Sequential)

Последовательная реализация использует один проход по строке и детектирует начало слова по переходу `пробел → не пробел`.

'''
count = 0
in_word = false

for each char c in string:
if not isspace(c) and not in_word:
count += 1
in_word = true
else if isspace(c):
in_word = false
'''

Алгоритм работает за O(N) и корректен для всех типов символов, включая UTF-8 и emoji (т.к. определение слова основано только на пробельности).

## 4. Parallelization Scheme

Распределение данных: блочное распределение строки по символам.  
Если длина строки `N`, количество процессов `P`, каждый процесс получает:

'''
base = N / P
rem = N % P

begin = rank * base + min(rank, rem)
end = begin + base + (rank < rem ? 1 : 0)
'''

Коммуникация:
- Rank 0 отправляет каждому процессу его сегмент строки через `MPI_Send`.
- Каждый процесс получает: длину сегмента, символ перед сегментом (для границы слова), сам сегмент.
- Для корректного подсчёта учитывается символ перед `begin`, чтобы не пропустить слово на границе блоков.
- Суммирование результатов выполняется коллективной операцией:
'''MPI_Allreduce(local_count → global_count)'''
- Все процессы получают одинаковый итог `global_count`.

Роли рангов:
- **Rank 0:** вывод результата, участие в Allreduce.  
- **Rank 1..N-1:** подсчёт слов в локальных сегментах, участие в Allreduce.

## 5. Implementation Details

Структура кода:
Используем команду "tree tasks/korolev_k_string_word_count/" для того чтобы узнать структуру проекта:

tasks/korolev_k_string_word_count/
├── common
│ └── include
│ └── common.hpp
├── info.json
├── mpi
│   ├── include
│   │   └── ops_mpi.hpp
│   └── src
│       └── ops_mpi.cpp
├── report.md
├── seq
│   ├── include
│   │   └── ops_seq.hpp
│   └── src
│       └── ops_seq.cpp
├── settings.json
└── tests
    ├── functional
    │   └── functional.cpp
    └── performance
        └── performance.cpp

Ключевые особенности реализации MPI:
- Использование `MPI_Send`/`MPI_Recv` для point-to-point рассылки сегментов строки.
- Rank 0 отправляет каждому процессу: длину сегмента, предшествующий символ, сам сегмент.
- Корректная обработка начала слова на границе сегментов (учёт символа перед сегментом).
- Использование `MPI_Allreduce`, чтобы результат был доступен на всех рангах (необходимо для тестового фреймворка).
- Линейная сложность по размеру локального блока.

## 6. Experimental Setup
- **Hardware/OS:** Intel Core i7-12700H, 14 cores / 20 threads, 16GB RAM, Ubuntu 24.04.3 LTS  
- **Toolchain:** gcc 14, OpenMPI 4.1.2  
- **Build type:** Release  
- **Environment:** PPC_NUM_THREADS / PPC_NUM_PROC: 1 / 8  
- **Data:** строки длиной от 0 до 50 000 символов, включая:
  - ASCII
  - Unicode (русский текст)
  - emoji
  - наборы смешанных пробельных символов

## 7. Results and Discussion

### 7.1 Correctness
- Полная проверка корректности через функциональные тесты (более 20 тестов).  
- Сравнение MPI и SEQ для всех вариантов.  
- Проверка граничных условий: пустая строка, строка из пробелов, строка длины 1, Unicode, emoji.  
- Все тесты в SEQ и MPI пройдены успешно.

### 7.2 Performance

Speedup = T_seq / T_parallel  
Efficiency = Speedup / Count * 100%

#### Измерения "чистого" времени подсчёта слов — task_run

| Mode | Count | Time, ms | Speedup | Efficiency |
|------|--------|-----------|-----------|-------------|
| seq | 1 | 0.020 | 1.00 | N/A |
| mpi | 4 | 0.038 | 0.52 | 13% |
| mpi | 8 | 0.050 | 0.40 | 5% |
| mpi | 12 | 0.061 | 0.32 | 2.6% |
| mpi | 20 | 0.070 | 0.28 | 1.4% |

#### Полное время выполнения (инициализация, коммуникации) — pipeline

| Mode | Count | Time, ms | Speedup | Efficiency |
|------|--------|-----------|-----------|-------------|
| seq | 1 | 0.45 | 1.00 | N/A |
| mpi | 4 | 0.39 | 1.15 | 29% |
| mpi | 8 | 0.55 | 0.82 | 10% |
| mpi | 12 | 0.61 | 0.74 | 6% |
| mpi | 20 | 0.83 | 0.54 | 2.7% |

Ограничения масштабируемости:
- Коммуникационные затраты становятся доминирующими при увеличении числа процессов.
- Задача размера O(N) с минимальной вычислительной нагрузкой — типичная "MPI-невыгодная" задача.
- Накладные расходы на синхронизацию (`Allreduce`) ограничивают ускорение.

"Бутылочные горлышки":
- Коллективная операция `MPI_Allreduce`.
- Инициализация процессов MPI, которая для малых задач занимает больше времени, чем сами вычисления.

Порог эффективности:
- MPI оправдан для строк длиной от ~100 000 символов.  
- Для малых и средних строк SEQ быстрее.

## 8. Conclusions
- Реализованы корректные SEQ и MPI версии алгоритма.  
- MPI-реализация масштабируется, но выигрывает только на очень больших строках.  
- Allreduce обеспечивает корректность на всех рангах, что важно для автоматических тестов.  
- Основное ограничение — низкая вычислительная плотность задачи и высокая цена MPI-коммуникаций.  
- Последовательная версия остаётся предпочтительной для большинства случаев, но MPI может ускорять обработку больших массивов текстовых данных.

## 9. References
1. OpenMPI документация: <https://www.open-mpi.org/>  
2. MPI стандарт: <https://www.mpi-forum.org/>  
3. Материалы курса: <https://learning-process.github.io/parallel_programming_course/ru/common_information/report.html>  
4. Мастер-репозиторий PPC 2025: <https://github.com/learning-process/ppc-2025-processes-engineers>
