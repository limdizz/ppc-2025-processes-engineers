# Подсчет числа предложений в строке

- Студент: Котельникова Анастасия Владимировна, группа 3823Б1ПР2
- Технологии: SEQ + MPI
- Вариант: 25

## 1. Введение

Задача подсчета числа предложений в строке представляет типичную проблему обработки текстовых данных. С ростом объема обрабатываемой информации последовательные алгоритмы демонстрируют снижение эффективности. Параллельная реализация позволит ускорить обработку и обеспечить корректность результатов.

Цель работы - разработать последовательный и параллельный алгоритмы подсчета числа предложений в строке и сравнить их производительность.

## 2. Постановка задачи

Задача: подсчитать число предложений в строке.

Входные данные: строка произвольной длины (типа `std::string`)
Выходные данные: число, равное количеству предложений в строке (типа `std::size_t`)

Ограничения строки:
- содержит текст только на английском языке;
- длина ограничивается доступной памятью;
- требуется хотя бы один буквенно-цифровой символ.

Ограничения предложения:
- может оканчиваться одним из явных символов: '.' (точка), '!'  (восклицательный знак), '?' (вопросительный знак);
- допускается вариант неявного окончания строки "знаком конца строки" при наличии предшествующих буквенно-цифровых символов;
- обработка множественных разделителей (пример: "!!!") не предустматривается;
- предложения должны быть разделены знаком пробела.

Ограничения программы:
- должна корректно обрабатывать символы отличные от символов окончания строки (цифровые и буквенные символы, а так же знаки: , (запятая), "" '' (скобки) и тд.);
- для параллельной реализации должна обеспечивать корректный подсчет на границах между процессами.

## 3. Базовый (последовательный) алгоритм (Sequential)

Работа последовательного алгоритма проходит через четыре этапа:
1. `ValidationImpl()` - проверяется, что строка, поступившая на вход, не пустая.
2. `PreProcessingImpl()` - подготовительный этап, дополнительных операций не выполняется.
3. `RunImpl()` - основной этап обработки строки.
   - инициализируются счетчик предложений (`sentence_count`) изначально равный нулю и неактивный флаг нахождения внутри предложения (`in_sentence`).
   - выполняется посимвольный анализ строки:
      - при обнаружении символа конца строки ('.', '!', '?') и активном флаге нахождения внутри предложения счетчик увеличитвается и флаг сбрасывается.
      - при обнаружении буквенно-цифрового символа флаг активируется.
   - после анализа строки дополнительно проверяется флаг нахождения в предложении, если он активен, то счетчик увеличивается.
   - полученный счетчиком результат записывается в выходные данные.
4. `PostProcessingImpl()` - завершающий этап, дополнительных операций не выполняется.

Полноценная реализация последовательного алгоритма представлена в Приложении (п.1).

## 4. Схема параллелизации

Идея параллелизации заключается в том, что строку можно разбить на некоторое число независимых частей и предоставить обработку каждой отдельному процессу. Каждый процесс ведет подсчет числа предложений в своей части, затем полученные результаты объединяются в итоговый ответ.

Распределение данных:
- Распределение строки: исходная строка делится на n-ое количество примерно равных частей, где n равняется числу процессов.
- Распределение нагрузки: для равномерного распределения используются следующие формулы:
   - вычисляется размер блока: длина строки делится (оператор `/`) на количество процессов;
   - вычисляется остаток: длина строки делится (оператор `%`) на количество процессов;
   - первые k блоков (где k - остаток от деления) получают блоки размера увеличенного на один;
   - остальные процессы получают блоки ранее вычисленного размера.
- Определение границ блоков:
   - начальная позиция вычисляется с учетом того, что первые процессы получают блоки увеличенного размера;
   - конечная позиция определяется как начальная позиция к которой прибавляют размер блока данного процесса.

Схема связи/топологии:
- Топология: коммуникатор MPI_COMM_WORLD.
- Коммуникационные операции: MPI_Allreduce - операция суммирования частичных результатов (каждый процесс передает свой локальный счетчик предложений, все процессы одновременно получают итоговый результат).

Ранжирование ролей:
Все процессы равноправны - выполняют идентичные функции:
1. Обработка своего сегмента строки:
   - определение начального состояния на границе сегмента;
   - подсчет предложений в пределах выделенного блока;
   - учет незавершенного предложения на конце (для последнего процесса).
2. Участие в коллективных операциях:
   - передача локального результата;
   - получение глобального результата.

Алгоритм обработки границ между процессами:
Для каждого процесса:
   - если обрабатывается не первый блок (`start > 0`):
      - анализируется символ, предшествующий блоку (`text[start-1]`);
      - определяется, начинается ли блок в середине предложения.
   - обрабатывается выделенный сегмент `[start, end)`;
   - если процесс обрабатывает последний блок: 
      - сегмент доходит до конца строки;
      - последнее предложение не завершено разделителем:
         - учитывается незавершенное предложение в конце строки.

Полноценная реализация распараллеленного алгоритма представлена в Приложении (п.2).

## 5. Детали реализации

Файловая структура:

kotelnikova_a_num_sent_in_line/  
├── common/include  
│   └── common.hpp                  # Базовые определения типов  
├── data/  
│   ├── test_1.txt                  # Тестовые данные  
│   ├── test_2.txt  
│   ├── test_3.txt  
│   ├── test_4.txt  
│   ├── test_5.txt  
│   └── test_6.txt  
├── mpi/  
│   ├── include/ops_mpi.hpp         # MPI версия    
│   └── src/ops_mpi.cpp  
├── seq/  
│   ├── include/ops_seq.hpp         # Последовательная версия  
│   └── src/ops_seq.cpp  
└── tests/  
    ├── functional/main.cpp         # Функциональные тесты  
    └── performance/main.cpp        # Производительные тесты  

Ключевые классы:
- KotelnikovaANumSentInLineSEQ - последовательная реализация.
- KotelnikovaANumSentInLineMPI - параллельная реализация.

Основные методы:
- ранее описанные (и одинаковые для обеих реализаций): 
   - `ValidationImpl()` - проверка входных данных;
   - `PreProcessingImpl()` - подготовительный этап;
   - `PostProcessingImpl()` - завершающий этап;
- `RunImpl()` - основной алгоритм обработки;
- `CountSentencesInChunk()` - подсчет предложений в сегменте (MPI);

Алгоритмические особенности:
- cостояние `in_sentence` передается между смежными процессами через анализ граничных символов;
- последний процесс ответственен за учет предложения, обрывающегося на конце строки;
- коллективная операция MPI_Allreduce обеспечивает синхронизацию результатов.

Пример обработки границ:
Строка: "Hello. How are you? I'm fine"
Процесс 0: "Hello. How " → 1 предложение (in_sentence = true)
Процесс 1: "are you? I'm" → 1 предложение + продолжение (in_sentence = true)
Процесс 2: " fine" → 1 предложение (учтено благодаря проверке конца строки)
Результат: 3 предложения.

## 6. Экспериментальная среда

Hardware/OS:
- процессор: Intel Core i5
- ядра/потоки: 8 ядер / 16 потоков
- оперативная память: 16 GB
- операционная система: Windows 11
- архитектура: x64

Toolchain:
- компилятор: Microsoft Visual C++ (MSVC)
- версия: Visual Studio Code 2019/2022
- тип сборки: Release
- система сборки: CMake
- версия MPI: Microsoft MPI 10.1

Environment:
- количество процессов: задается через mpiexec -n N
- коммуникатор: MPI_COMM_WORLD

Тестовые данные: 
1. Функциональные тесты: 
   - тестовые данные из фалов
2. Перформанс тесты:
   - сгенерирована строка из 10000 предложений
   - длина предложений: 15-30 слов
   - длина слов: 7-25 символов
   - общий размер строки: 8000000 символов

## 7. Результаты и обсуждение

### 7.1 Корректность

Корректность реализации была проверена следующими методами:
- разработано 6 функциональных тестов с заранее известными ожидаемыми результатами;
- тесты охватывают различные сценарии: 
   - простые предложения с разными разделителями ('.', '!', '?');
   - cтроки без разделителей в конце;
   - различные комбинации буквенно-цифровых символов и разделителей.

Сравнение последовательной и параллельной версий:
- последовательная версия служит эталоном для проверки параллельной реализации;
- обе версии проходят идентичный набор тестов с одинаковыми входными данными;
- результаты последовательного и MPI алгоритмов полностью совпадают для всех тестовых случаев.

### 7.2 Производительность

Методы измерений:
- Каждый тест запускается 5 раз
- Берется среднее время выполнения (ΣTime / 5)
- Speedup = Time_seq / Time_mpi
- Efficiency = Speedup / Count * 100%

| Mode        | Count | Time, s  | Speedup | Efficiency |
|-------------|-------|----------|---------|------------|
| seq         | 1     | 0.02173  | 1.00    | N/A        |
| mpi         | 2     | 0.01147  | 1.89    | 94,50%     |
| mpi         | 4     | 0.00569  | 3.82    | 95,50%     |
| mpi         | 6     | 0.00550  | 3.95    | 65,83%     |

Анализ результатов:
- Хорошее ускорение - до 3.95 раз на 6 процессах
- Высокая эффективность на 2 и 4 процессах (>90%)
- Снижение эффективности на 6 процессах (~65%) - происходит из-за накладных расходов MPI

## 8. Заключение
В ходе работы была успешно решена задача подсчета числа предложений в строке с использованием последовательного алгоритма и технологии MPI для параллельных вычислений.

Основные результаты:
- разработан корректный алгоритм - созданы последовательная и параллельная версии, прошедшие полное тестирование.
- реализована эффективная схема распараллеливания - применено блочное распределение строки между процессами с корректной обработкой границ предложений на стыках блоков.
- достигнуто значительное ускорение - параллельная реализация демонстрирует ускорение до 3.65 раз на 6 процессах по сравнению с последовательной версией.

## 9. Источники
1. Документация по курсу «Параллельное программирование» // URL: https://learning-process.github.io/parallel_programming_course/ru/index.html
2. Репозиторий курса «Параллельное программирование» // URL: https://github.com/learning-process/ppc-2025-processes-engineers
3. Сысоев А. В., Лекции по курсу «Параллельное программирование для кластерных систем».

## Приложение
П.1
```cpp
bool KotelnikovaANumSentInLineSEQ::RunImpl() {
  const std::string &text = GetInput();
  std::size_t sentence_count = 0;
  bool in_sentence = false;

  for (std::size_t i = 0; i < text.length(); ++i) {
    char current_symb = text[i];

    if (current_symb == '.' || current_symb == '!' || current_symb == '?') {
      if (in_sentence) {
        sentence_count++;
        in_sentence = false;
      }
    } else if (std::isalnum(static_cast<unsigned char>(current_symb)) != 0) {
      in_sentence = true;
    }
  }

  if (in_sentence) {
    sentence_count++;
  }

  GetOutput() = sentence_count;
  return true;
}
```

П.2
```cpp
bool KotelnikovaANumSentInLineMPI::RunImpl() {
  const std::string &text = GetInput();

  int world_size = 0;
  int world_rank = 0;
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

  int total_length = static_cast<int>(text.length());
  int chunk_size = total_length / world_size;
  int remainder = total_length % world_size;

  int start = (world_rank * chunk_size) + std::min(world_rank, remainder);
  int end = start + chunk_size + (world_rank < remainder ? 1 : 0);
  end = std::min(end, total_length);

  int local_count = CountSentencesInChunk(text, start, end, world_rank, world_size, total_length);

  int global_count = 0;
  MPI_Allreduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  GetOutput() = static_cast<std::size_t>(global_count);
  return true;
}

int KotelnikovaANumSentInLineMPI::CountSentencesInChunk(const std::string &text, int start, int end, int world_rank,
                                                        int world_size, int total_length) {
  int count = 0;
  bool in_sentence = false;

  if (start > 0) {
    char prev_char = text[static_cast<std::size_t>(start - 1)];
    bool is_prev_sentence_end = (prev_char == '.' || prev_char == '!' || prev_char == '?');
    bool is_prev_word_char = (std::isalnum(static_cast<unsigned char>(prev_char)) != 0);
    in_sentence = !is_prev_sentence_end && is_prev_word_char;
  }

  for (int i = start; i < end; ++i) {
    char c = text[static_cast<std::size_t>(i)];

    if (c == '.' || c == '!' || c == '?') {
      if (in_sentence) {
        count++;
        in_sentence = false;
      }
    } else if (std::isalnum(static_cast<unsigned char>(c)) != 0) {
      in_sentence = true;
    }
  }

  if (in_sentence && world_rank == (world_size - 1) && end == total_length) {
    count++;
  }

  return count;
}
```