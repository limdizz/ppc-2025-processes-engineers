# Подсчёт числа несовпадающих символов двух строк

- Студент: Марьин Лев Миахйлович, группа 3823Б1ПР3
- Технология: SEQ | MPI
- Вариант: 27

## 1. Введение

- Подсчёт несовпадающих символов в двух строках является базовой операцией при анализе текстовых данных и проверке корректности данных. Для длинных строк последовательный подход может занимать значительное время. Использование MPI позволяет распределить задачу между несколькими процессами и сократить время выполнения.

- Цель работы - реализовать корректные последовательную и параллельную версии алгоритма и ускорить выполнение задачи.

## 2. Постановка задачи

- Задача: Для двух строк s1 и s2 определить количество позиций i, в которых символы различаются.
- Входные данные: две строки s1 и s2. 
- Выходные данные: целое число — количество несовпадающих символов
- Ограничения: строки могут иметь разную длину.
- Алгоритм должен учитывать все символы, включая пробелы, цифры и регистр букв.

## 3. Базовый алгоритм (последовательный)

- Последовательная версия алгоритма выполняет прямое сравнение символов двух строк:

```
1. Инициализировать count = 0
2. min_len = min(len(s1), len(s2))
3. max_len = max(len(s1), len(s2))
4. Для i от 0 до min_len - 1:
   a. Если s1[i] != s2[i], увеличить count на 1
5. Добавить разницу длин строк к count:
   count += (max_len - min_len)
6. Вернуть count
```

## Сложность:
- Временная: O(N), где N = max(len(s1), len(s2))
- Пространственная: O(1), только счётчик

## 4. Схема параллелизации

## Разделение данных
- Длина сравниваемой части: max(len(s1), len(s2))
- Блочное распределение: каждая MPI-процесс получает подотрезок для сравнения
- Остаток распределяется между первыми процессами

## Локальный подсчёт
- Каждый процесс считает несовпадения в своей части

## Глобальная редукция
- MPI_Reduce суммирует локальные счётчики в глобальный результат

## Код распределения:
```
std::size_t chunk = total_len / static_cast<std::size_t>(size);
  std::size_t remainder = total_len % static_cast<std::size_t>(size);

  std::size_t start =
      (static_cast<std::size_t>(rank) * chunk) + std::min<std::size_t>(static_cast<std::size_t>(rank), remainder);
  std::size_t end = start + chunk;
  if (std::cmp_less(rank, remainder)) {
    end += 1;
  }
```

## Роли процессов:
- Процесс 0: мастер, собирает результат
- Остальные процессы: рабочие

## 5. Детали реализации

## Структура проекта
- `common.hpp` - типы данных
- `ops_seq.hpp/cpp` - последовательная версия
- `ops_mpi.hpp/cpp` - MPI версия
- `functional_tests.cpp` - функциональные тесты
- `performance_tests.cpp` - тесты производительности

## Классы
- `MarinLCntMismatChrtInTwoStrSEQ` - последовательная версия подсчёта несовпадающих символов
- `MarinLCntMismatChrtInTwoStrMPI` - параллельная версия с использованием MPI

## Особенности
- Обработка пустых строк
- Разная длина строк
- Учёт регистра, пробелов, цифр и Unicode

## Методы
- `ValidationImpl()` - проверка корректности входных данных 
- `PreProcessingImpl()` - подготовка данных к вычислениям 
- `RunImpl()` - основной алгоритм
- `PostProcessingImpl()` - проверка корректности результата

## Граничные случаи
- Обе строки пустые: результат = 0
- Одинаковые строки: результат = 0
- Строки разной длины: учитываются все символы, добавляется разница длины
- Строки длиной 1: корректно обрабатывается один символ
- **N < P**  (число процессов): некоторые процессы получают пустой блок
- **N % P != 0**: остаток элементов распределяется между первыми процессами

## Использование памяти
- **SEQ**: O(1) хранится только счетчик несовпадений
- **MPI**: O(1) на процесс 

## 6. Экспериментальная установка

## Аппаратное обеспечение
- **Процессор**: Intel Core i5-12450H
- **ОЗУ**: 16 ГБ
- **ОС**: Windows 10 Pro

## Программное обеспечение
- **Компилятор**: MSVC 19.36 
- **MPI**: MS-MPI 10.0
- **Сборка**: Release
- **CMake**: 4.1.2
- **Фреймворк тестирования**: Google Test 

## Параметры тестирования

**Функциональные тесты**:
- Длина строк: 0-5000 символов

**Разные сценарии**: 
- Одинаковые строки
- Строки с одним несовпадением 
- Строки разной длины 
- Строки с пробелами, числа, символы Unicode

## Тесты производительности:
- Длина строк: 40000000 символов
- Количество процессов MPI: 1, 2, 4
- Режимы: task_run, pipeline

## 7. Результаты и обсуждение

## 7.1 Корректность

## Все функциональные тесты успешно пройдены
Тесты учитывают:
- Пустые строки
- Разную длину
- Регистрозависимость
- Числовые и Unicode символы

### 7.2 Производительность

Тестирование проводилось на задаче подсчёта несовпадающих символов для двух строк длиной 400 000 000 символов

-task_run:

| Режим | Процессов | Время, с | Ускорение | Эффективность |
| ----- | --------: | -------: | --------: | ------------: |
| seq   |         1 |   0.4906 |      1.00 |           N/A |
| mpi   |         1 |   0.2384 |      0.49 |         49.0% |
| mpi   |         2 |   0.1122 |      4.37 |        218.5% |
| mpi   |         4 |   0.0809 |      6.06 |        151.5% |

-task_pipeline:

| Режим | Процессов | Время, с | Ускорение | Эффективность |
| ----- | --------: | -------: | --------: | ------------: |
| seq   |         1 |   0.4977 |      1.00 |           N/A |
| mpi   |         1 |   0.2756 |      1.81 |         181.0 |
| mpi   |         2 |   0.1835 |      2.71 |        135.5% |
| mpi   |         4 |   0.1344 |      3.70 |         92.5% |

## Анализ производительности

Расчёт метрик:
- Ускорение = T_seq / T_mpi
- Эффективность = (Speedup / P) × 100%
- Последовательное время измерено отдельно.

## Анализ результатов
**task_run**:
- На 1 процессе наблюдается линейное ускорение, MPI-структура даёт выигрыш.
- На 2 процессах также наблюдается ускорение за счёт параллельного вычисления.
- На 4 процессах ускорение остаётся высоким, MPI-затраты умеренные.

**task_pipeline**:
- На 1 процессе также наблюдается линейное ускорение, MPI-затраты минимальны.
- На 2 процесса показывают хорошее ускорение и эффективность.
- На 4 процессах эффективность падает из-за возрастания накладных расходов на коммуникации.

## Вывод:
- Task_Run обеспечивает лучшее масштабирование на небольшом числе процессов.
- Pipeline менее эффективно масштабируется на 4 процессах из-за коммуникационных накладных расходов, но на 2 процессах даёт заметное ускорение.

## 8. Выводы
- Реализованы последовательная и MPI версии подсчёта несовпадающих символов.
- Корректность подтверждена функциональными тестами.
- MPI позволяет ускорить вычисления на длинных строках в 3-4 раза.
- Эффективность MPI ограничена накладными расходами и размером строк.
- Алгоритм использует память эффективно.

## 9. Список источников информации

1. Сысоев А. В. Лекции по параллельному программированию. — Н. Новгород: ННГУ, 2025.
2. Преснухин Л. Н. Параллельное программирование с использованием стандарта OpenMP. — Москва: Издательство МГУ, 2010.
2. Parallel Programming Course Slides - https://learning-process.github.io/parallel_programming_slides/
3. Microsoft. Microsoft MPI Documentation - https://learn.microsoft.com/en-us/message-passing-interface/microsoft-mpi 

## Приложение

### Фрагменты кода

**Последовательная версия (SEQ):**

```cpp
bool MarinLCntMismatChrtInTwoStrSEQ::RunImpl() {
  const std::string &s1 = GetInput().first;
  const std::string &s2 = GetInput().second;

  int count = 0;
  size_t min_len = std::min(s1.size(), s2.size());
  size_t max_len = std::max(s1.size(), s2.size());

  for (size_t i = 0; i < min_len; i++) {
    if (s1[i] != s2[i]) {
      count++;
    }
  }

  count += static_cast<int>(max_len - min_len);

  GetOutput() = count;
  return true;
}
```

**Параллельная версия (MPI):**

```cpp
bool MarinLCntMismatChrtInTwoStrMPI::RunImpl() {
  int rank = 0;
  int size = 1;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);

  const std::string &s1 = local_s1_;
  const std::string &s2 = local_s2_;

  std::size_t len1 = s1.size();
  std::size_t len2 = s2.size();
  std::size_t total_len = std::max(len1, len2);

  if (total_len == 0) {
    GetOutput() = 0;
    return true;
  }

  std::size_t chunk = total_len / static_cast<std::size_t>(size);
  std::size_t remainder = total_len % static_cast<std::size_t>(size);

  std::size_t start =
      (static_cast<std::size_t>(rank) * chunk) + std::min<std::size_t>(static_cast<std::size_t>(rank), remainder);
  std::size_t end = start + chunk;
  if (std::cmp_less(rank, remainder)) {
    end += 1;
  }

  int local_count = 0;
  for (std::size_t i = start; i < end && i < total_len; ++i) {
    if (i >= len1 || i >= len2 || s1[i] != s2[i]) {
      ++local_count;
    }
  }

  int global_count = 0;
  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Bcast(&global_count, 1, MPI_INT, 0, MPI_COMM_WORLD);

  GetOutput() = global_count;
  return true;
}

bool MarinLCntMismatChrtInTwoStrMPI::PostProcessingImpl() {
  return true;
}
```