# Нахождение наиболее близких соседних элементов вектора

- Студент: Мельник Иван Вадимович, группа 3823Б1ПР1
- Технологии: SEQ, MPI
- Вариант: 7

## 1. Введение 
В данной работе рассматривается задача поиска двух соседних элементов вектора, имеющих минимальную разницу значений.
Цель работы — разработать последовательную и MPI-параллельную версии алгоритма, сравнить их производительность на разных размерах входных данных и проанализировать влияние коммуникаций на масштабируемость.
## 2. Постановка задачи
**Формальная постановка**\
На вход подается вектор из целых чисел. Требуется найти индекс `i` такой, что разница по модулю элементов вектора с индексами `i` и `i+1` минимальна. На выходе - кортеж индексов `(i, i+1)`\
**Дополнительные требования и ограничения**
 - При равенстве минимальных разностей выбирается пара с наименьшим левым индексом;
  - Алгоритмы должны корректно работать при любых значениях элементов вектора;
  - При одинаковом наборе входных данных параллельная и последовательная реализации должны давать одинаковый результат;
  - Параллельный алгоритм должен быть реализован с помощью MPI. Также он должен корректно работать при любом количестве процессов.

## 3. Базовый алгоритм (последовательная версия)
**Идея**\
За один проход по вектору вычислить модуль разности соседних элементов и выбрать среди них минимальную.\
**Этапы алгоритма**
1. Создание диапазона индексов от `0` до `v.size() - 2` включительно, где `v` - входной вектор целых чисел. Реализовано с помощью `std::views::iota(size_t{0}, v.size() - 1)`;
2. Реализация лямбда-функции `comparator`, которая принимает индексы `i` и `j` и сравнивает между собой разности двух пар элементов вектора `(v[i], v[i+1])` и `(v[j], v[j+1])` и выбирает среди них меньшую, а при равенстве - выбирает наименьший левый индекс;
3. Поиск индекса пары с минимальной разницей в векторе с помощью `std::ranges::min_element(iota_range, comparator)`;
4. Формирование выходных данных в виде кортежа `(min_idx, min_idx + 1)`.
## 4. Схема распараллеливания
### 4.1. Общая идея
Алгоритм параллельно вычисляет локальные минимумы разностей в сегментах вектора, обменивает граничные значения для проверки граничных пар и объединяет результаты через коллективную операцию MPI.
### 4.1. Алгоритм параллельного выполнения
 1. Инициализация: Все процессы запускаются в коммуникаторе `MPI_COMM_WORLD`;
 2. Распределение данных: Root-процесс равномерно распределяет вектор с помощью `MPI_Scatterv` с распределением остатка – первые процессы получают дополнительные элементы. Каждый процесс вычисляет свое глобальное смещение через MPI_Scan;
 3. Локальные вычисления: Каждый процесс находит локальный минимум разностей пар, которые полностью входят в локальном блоке данных, корректируя индексы на глобальные;
 4. Обмен границами: Если процессов >1, неблокирующий обмен граничными элементами (`MPI_Isend/Irecv`) для проверки пар на стыках блоков данных;
 5. Агрегация результатов: Локальные минимумы (используется вспомогательная структура `Result{delta, index}`) объединяются с `MPI_Reduce` (`MPI_MINLOC`), затем результат рассылается MPI_Bcast.
### 4.2. Топология процессов
Все процессы равноправны между собой (за исключением root-процесса): вычисляют локальные минимумы, участвуют в обмене данными между соседними процессами и в редукции. Root-процесс дополнительно распределяет данные. Результат доступен на всех процессах.
## 5. Детали реализации
### 5.1. Структура реализации
```text
melnik_i_min_neigh_diff_vec
    ├───common
    │   └───include
    │           common.hpp - определение типов входных/выходных/тестовых данных
    │
    ├───mpi
    │   ├───include
    │   │       ops_mpi.hpp - заголовочный файл MPI-реализации
    │   │
    │   └───src
    │           ops_mpi.cpp - код MPI-реализации
    │
    ├───seq
    │   ├───include
    │   │       ops_seq.hpp - заголовочный файл SEQ-реализации
    │   │
    │   └───src
    │           ops_seq.cpp - код SEQ-реализации
    │
    └───tests
        ├───functional
        │       main.cpp - функциональные тесты
        │
        └───performance
                main.cpp - тесты производительности
```
### 5.2. Основные классы / функции
- `MelnikIMinNeighDiffVecSEQ` - последовательная реализация
- `MelnikIMinNeighDiffVecMPI` - параллельная реализация с вспомогательными методами
    - `ScatterData(...)`
    - `ComputeLocalMin(...)`
    - `HandleBoundaryDiffs(...)`
    - `PerformBoundaryCommunications(...)`
    - `UpdateResultWithBoundaryDiffs(...)`
    - `UpdateLocalResult(...)`
    - `ReduceAndBroadcastResult(...)`
### 5.3. Обработка граничных случаев и замечания
- Выбирается пара с минимальным левым индексом
- Реализации работают только при валидных размерах входных данных (`n >= 2`)
### 5.4. Пространственная и временная сложности алгоритмов
- Последовательная версия:
    - Временная сложность - `O(N)`, где `N` - размер входного вектора;
    - Пространственная сложность - `O(N)`, где `N` - размер вектора индексов, равный размеру входного вектора.
- Параллельная версия:
    - Временная сложность - `O(N/P + logP)`, где `N` - размер входного вектора, `P` - количество процессов. Слагаемое `N/P` - сложность локальных вычислений, `logP` - сложность операции `MPI_Reduce`;
    - Пространственная сложность: на "вычислительных процессах" - `O(N/P)`, на root-процессе - `O(N)`, где `N` - размер входного вектора, `P` - количество процессов.
## 6. Тестовая инфраструктура
### 6.1. Аппаратное обеспечение:
| Параметр | Значение                                                                               |
| -------- | -------------------------------------------------------------------------------------- |
| CPU      | Intel Core i5-11400F (6 cores, 12 threads, 2.6 GHz, up to 4.40 Ghz, L3 Cache 12 MB)    |
| RAM      | 32 GB DDR4 (3200 MHz)                                                                  |
### 6.2. Программное обеспечение:
| Параметр   | Значение                                               |
| ---------- | ------------------------------------------------------ |
| ОС         | Windows 10 Pro 22H2 (19045.5965) + WSL (Ubuntu 13.3.0) |
| MPI        | OpenMPI 3.1                                            |
| Компилятор | g++ 14.2.0                                             |
| Сборка     | Release                                                |
### 6.3. Тестовые данные
**Функциональные тесты:**\
Используют заранее подготовленный массив пар `вектор - описание тестового случая`. Корректность ответа проверяется в функции `CheckTestOutputData` с помощью вычисления ответа последовательным алгоритмом.\
**Тесты производительности:**\
Вектор размером 200000000 генерируется случайным образом, диапазон значений: от -1000000 до 1000000
## 7. Результаты и обсуждение
### 7.1 Корректность
Проверка корректности реализована средствами Google Test:
- 20 функциональных тестов покрывают: монотонные последовательности, постоянные векторы, отрицательные значения, чередующиеся знаки, большие значения, небольшие/средние/большие размеры вектора.
- Perf-тест проверяет, что результат даёт валидный индекс

Реализации успешно проходят функциональное тестирование
### 7.2 Производительность
**Метрики:**
1. Абсолютное время выполнения вычислительной части алгоритма в миллисекундах;
2. Ускорение относительно последовательной версии;
3. Эффективность распараллеливания = `(ускорение / число процессов) * 100%`.

**Размер вектора = 100000000**

| Режим | Процессы | Время, мс | Ускорение | Эффективность |
| ----- | -------- | --------- | --------- | ------------- |
| seq   | 1        | 2011      | 1.000     | N/A           |
| mpi   | 2        | 1565      | 1.284     | 64.24%        |
| mpi   | 4        | 1710      | 1.176     | 29.40%        |

**Размер вектора = 200000000**

| Режим | Процессы | Время, мс | Ускорение | Эффективность |
| ----- | -------- | --------- | --------- | ------------- |
| seq   | 1        | 4181      | 1.000     | N/A           |
| mpi   | 2        | 3403      | 1.228     | 61.43%        |
| mpi   | 4        | 3152      | 1.326     | 33.16%        |

**Анализ полученных результатов:**
1. Эффективность получилась примерно одинакова (и довольно низка) на разных размерах входных данных, что говорит о том, что расходы на MPI-коммуникации довольно велики;
2.  С ростом вектора улучшается эффективность, так как расходы на коммуникации MPI начинают играть меньшую роль на фоне вычислений;
3. Общая производительность кода довольно низка, так как мы сильно ограничены пропускной способностью и задержками ОЗУ (малый и большой векторы весят 381 и 762 Мб соответственно, они не помещаются в L3 кеш) на фоне того, что процессор способен быстро вычислять и сравнивать разницу целых чисел
## 8. Выводы
В ходе работы был реализован, протестирован и исследован на производительность алгоритм поиска двух ближайших по значению соседних элементов вектора в последовательной и параллельной версиях.

Параллельная версия позволила распределить вычисления между процессами и уменьшить общее время выполнения, однако ускорение оказалось умеренным. Наибольший выигрыш достигается при использовании двух процессов, дальнейшее увеличение числа процессов приводит к снижению эффективности. Это связано с довольно высокой стоимостью MPI-коммуникаций и с "бутылочным горлышком" в виде пропускной способности и задержек ОЗУ. Увеличение размера входных данных улучшает соотношение «вычисления к коммуникациям», но не приводит к линейному ускорению.

В целом, работа демонстрирует, что MPI-параллелизация для данной задачи потенциально полезна, но ограничена архитектурными и алгоритмическими особенностями. Как итог, наилучший эффект достигается при умеренном числе процессов.

## 9. Источники
1. Документация по курсу «Параллельное программирование» // Parallel Programming Course URL: https://learning-process.github.io/parallel_programming_course/ru/index.html (дата обращения: 10.11.2025).
2. Ranges library // Cppreference URL: https://en.cppreference.com/w/cpp/ranges.html (дата обращения: 12.11.2025).
3. std::ranges::iota_view // Cppreference URL: https://en.cppreference.com/w/cpp/ranges/iota_view.html (дата обращения: 12.11.2025).
4. Open MPI v3.1.6 documentation // Open MPI URL: https://www.open-mpi.org/doc/v3.1/ (дата обращения: 12.11.2025).
5. Intel® Core™ i5-11400F Processor // Intel® Products URL: https://www.intel.com/content/www/us/en/products/sku/212271/intel-core-i511400f-processor-12m-cache-up-to-4-40-ghz/specifications.html (дата обращения: 18.11.2025).