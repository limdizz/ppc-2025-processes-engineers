# Подсчет числа предложений в строке

- **Студент**: Морозов Никита Александрович, группа 3823Б1ПР1
- **Технология**: SEQ | MPI
- **Вариант**: 25

## 1. Введение
Строки - это популярный тип данных, встречающий практически во всех программах. Одна из областей работы со строками - алгоритмы анализа текста. Работа со строками требует эффективных алгоритмов, дабы ускорить общую работоспобность приложений. При помощи современных технологий ускорение можно достичь при помощи параллелизма.  
 
Цель моей работы - реализовать алгоритм подсчета числа предложений в строке, распараллелить его при помощи технологии MPI

## 2. Постановка задачи
Дана строка размера `n` 

Требуется определить колличество предложений внутри строки

Тип входных данных:
```cpp
using InType = std::string;
```
Тип выходных данных:
```cpp
using OutType = std::size_t;
```
Ограничения:
- Предложением считается последовательность символов оканчивающаяся на '.', или '!', или '?', или на любую комбинацию этих символов.
- Текст не может начинаться с '.', или '!', или '?'.
- Текст внутри строки не содержет предложений с цитированием.
- Любые сокращения в тексте означают окончание предложения.

## 3. Базовый алгоритм (последовательная версия) 
Алгоритм представляет собой проход по строке в цикле. 

Каждый элемент сравнивается с элементов окончания строки.
**Если** элемент равен, **то** проверяется предыдущий за ним на то же условие:
    **если** предыдущий элемент не равен, 
    **то** счетчик числа предложений увеличивается;
**иначе** ничего не происходит

Код алгоритма:
```cpp
std::size_t counter = 0;
for (size_t i = 0; i < input.length(); i++) {
  if ((input[i] == '.' || input[i] == '!' || input[i] == '?') && (input[i - 1] != '.') && (input[i - 1] != '?') &&
      (input[i - 1] != '!')) {
    counter++;
  }
}
```
**Характеристики:**

| Параметр                  | Значение |
|---------------------------|----------|
| Сложность по времени      | O(n)     |
| Сложность по памяти       | O(1)     |

## 4. Схема распараллеливания
Расспараллеливание алгоритма происходило по **схеме распараллеливания по данным**: исходная строка разбивалась на равные части между всеми процессами, каждый процесс обрабатывал свою часть.

## 4.1. Алгоритм распределения
**Код**
```cpp
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  step = input.length() / mpi_size;
  index_start = step * rank;
  index_end = step + index_start;
  if (rank == mpi_size - 1) {
    index_end = input.length();
  }
```

**Описание**
1. Исходная строка передается как входной аргумент всем процессам.
2. Каждый процесс узнает свой ранк `rank` и количество всех процессов в программе `mpi_size`.
3. Расчитвается размер обрабтываемой области для каждого процесса:
    1. Длина строки делится на количество всех процессов `step`.
    2. Вычисляется индекс начала участка обработки: step * rank `index_start`.
    3. Вычисляется индекс конца участка обработки: index_start + step `index_end.
    4. Если ранк процесса равен `mpi_size` - 1, то `index_end` = длине строки.

### 4.2. Алгоритм подсчета
Кажддый процесс выполняет подсчет на своем участке:
```cpp
std::size_t counter = 0;
for (std::size_t i = index_start; i < index_end; i++) {
  if ((input[i] == '.' || input[i] == '!' || input[i] == '?') && (input[i - 1] != '.') && (input[i - 1] != '?') &&
      (input[i - 1] != '!')) {
    counter++;
  }
}
```
### 4.3. Получение конечного результата
`MPI_Reduce()` - обеспечивает суммирование результатов локальных подсчетов на каждом процессе и отправляет полученную сумму на процесс с ранком 0.
**Код**
```cpp
MPI_Reduce(&k_counter, &counter_sum, 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);
```
Полученный результат процесс с раном 0 отправляет всем остальным процессам при помощи вызова `MPI_Bcast()`.
**Код**
```cpp
MPI_Bcast(&counter_sum, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);
```
### 4.4. Схема работы программы
Схема представлена для 3х процессов
```
┌──────────────────────────────┐
│  Входные данные (строка A)   │
└────────┬─────────────────────┘
         │ (передача входных аргументов программе)
         ↓
 ┌────────────────┬────────────────┬────────────────┐
 │  Процесс 0     │  Процесс 1     │  Процесс 2     │  
 │ получает A     │ получает A     │ получает A     │
 └───────┬────────┴────────────────┴────────────────┘
         │ (вычисление индекса обрабатываемого участка)
         ↓
 ┌────────────────┬────────────────┬────────────────┐
 │ index_start(0) │ index_start(1) │ index_start(2) │
 | index_end(0)   │ index_end(1)   │  index_end(2)  │
 └───────┬────────┴────────────────┴────────────────┘
         │ (локальный подсчет числа предложений)
         ↓
 ┌───────────────┬─────────────────┬─────────────────┐
 │ local_sum(0)  │ local_result(1) │ local_result(2) │
 └───────┬───────┴─────────────────┴─────────────────┘
         │ MPI_Reduce
         ↓
┌───────────────────────────────────┐
│  Процесс 0 получает global_sum    │
└────────┬──────────────────────────┘
         │ MPI_Bcast
         ↓
┌─────────────────────────────────────────────┐
│   Все процессы получают итоговое значение   │
│  Сохранение: GetOutput() = global_result    │
└─────────────────────────────────────────────┘
```

## 5. Детали реализации
**Структура проекта**
|          Файл          |                 Назначение                  |
|------------------------|---------------------------------------------|
| `common.hpp`           | Определение входных и выходных типов задачи |
| `ops_seq.hpp/.cpp`     |         Последовательная реализация         |
| `ops_mpi.hpp/.cpp`     |                MPI-реализация               |
| `functional/main.cpp`  |             Функциональные тесты            |
| `performance/main.cpp` |       Тестирование производительности       |

## 6. Экспериментальная среда

|  Компонент |               Значение                       |
|------------|----------------------------------------------|
|     CPU    |           Apple M2 (8 cores)                 |
|     RAM    |                 16 GB                        |
|     ОС     | OS: Ubuntu 24.04 (DevContainer / macOs 15.6) |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release      |
|     MPI    |        mpirun (Open MPI) 4.1.6               |

Тестовые данные: 
1. Функциональные тесты: 
    - тестовые данные из фалов
    - сгенерироавнная строка из 10 предложений случайной длины (от 65 до 122 символов)
2. Перформанс тесты:
    - сгенерироавнная строка из 4'000'000 предложений случайной длины (от 65 до 122 символов)

Генерация данных происходила при помощи стандартной библиотеки C++.

## 7. Результаты и обсуждение

### 7.1 Корректность
Функциональные тесты используют входные файлы или генерацию в зависимости от параметра теста.

Струкутра параметра теста:
- номер теста (число)
- строка (может быть пустой)
- результат 

Тест считывает второй аргумент параметра и, если он не пустой, считывает входной файл.
Входные файлы имеют следующие наименования:
```
test_1.txt
test_2.txt
...
```
Если тест во втором аргументе параметра считал пустую строку, то данные будут сгенерированны, количество предложений в сгенерированных данных будет равно третьему аргументу параметра.

Обе реализации (`SEQ`, `MPI`) прошли все тесты успешно.

### 7.2 Производительность

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0.2387  | 1.00    | N/A        |
| omp         | 2     | 0.1163  | 2.05    | 102.5%     |
| omp         | 4     | 0.0600  | 3.98    | 99.5%      |

## 8. Заключение
В ходе выполнения работы:
- реализовал алгоритм подсчета предложений в строке
- распараллелил его при помощи технологии MPI
- рассчитал характекристик ускорение и эффективности для распараллеленного алгоритма
- выяснил, что параллельная обработка позволила ускорить алгоритм

## 9. Источники
1. Сысоев А. В. Курс лекций по параллельному программированию
2. Документация Open MPI     https://www.open-mpi.org/doc/
3. Microsoft Функции MPI     https://learn.microsoft.com/ru-ru/message-passing-interface/mpi-functions