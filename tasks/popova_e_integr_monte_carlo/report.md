# Интегрирование – метод Монте-Карло

- **Студент**: Попова Елизавета Сергеевна, группа 3823Б1ПР1
- **Технология**: SEQ | MPI
- **Вариант**: 21

## 1. Введение
Метод Монте-Карло — численный метод, основанный на использовании случайных точек в заданном интервале для приближенного вычисления значения интегралов и оценке интеграла как среднего значения функции в этих точках, умноженного на меру области.

Цель работы — реализовать алгоритм вычисления определенного интеграла методом Монте-Карло, распараллелить его с помощью технологии MPI.

## 2. Постановка задачи
Задача: реализовать последовательную (SEQ) и параллельную (MPI) версию интегрирования методом Монте-Карло для функции.

Даны границы интегрирования `a` и `b`, количество точек `n` и идентификатор функции `func_id`.
Набор возможных функций задается:
```cpp
enum class FuncType : std::uint8_t {
  kLinearFunc = 0,     // 2x + 7
  kQuadraticFunc = 1,  // 5x - 3x^2 + 7
  kCubicFunc = 2,      // x^3 - 4x
  kCosFunc = 3,        // cos(2x)
  kExpFunc = 4         // 2x * exp(-2x) + 4
};
```
Требуется вычислить определенный интеграл функции на отрезке `[a, b]` методом Монте-Карло.

Тип входных данных, где: 
```cpp
using InType = std::tuple<double, double, int, FuncType>;
```
- `a` — нижняя граница интегрирования типа double;
- `b` — верхняя граница интегрирования типа double;
- `n` — количество случайных точек типа int;
- `func_id` — идентификатор функции типа FuncType.

Тип выходных данных, где: 
```cpp
using OutType = double;
```
- `integral` — приблизительный результат интеграла типа double.

Ограничения для входных данных:
- `a` должно быть строго меньше `b`;
- `n` должно быть положительным целым числом;
- `func_id` должен принадлежать диапазону `[kLinearFunc, kExpFunc]`, то есть быть одной из заданных функций. 


## 3. Базовый алгоритм (последовательная версия) 
Последовательная версия алгоритма состоит из 4-х этапов:
1. `ValidationImpl()`: проверяем, что поступившие входные данные соответствуют органичениям.
2. `PreProcessingImpl()`: подготовительный этап;
3. `RunImpl()`: основной этап вычисления интеграла. В основе метода:
- Генерируется n точек на отрезке `[a, b]` посредством квазислучайной последовательности;
- На каждой итерации вычисляется новая точка `x` на отрезке`[a, b]`;
- Вычисляется значение функции в каждой точке: `fx = FunctionPair::Function(func_id_, x);`;
- Суммируется значение функций;
- Вычисляется среднее значение: `(1/n) * SUM (f (xi)) = S`;
- Производится оценка интеграла: `I = (b - a) * S`.
1. `PostProcessingImpl()`: завершающий этап.  

Код алгоритма метода Монте-Карло: 
```cpp
  const double magic_constant = 0.75487766624669276;
  double current = 0.5;
  double sum = 0.0;
  for (int i = 0; i < point_count_; ++i) {
    current += magic_constant;
    if (current >= 1.0) {
      current -= 1.0;
    }
    double x = a_ + ((b_ - a_) * current);
    double fx = 0.0;
    fx = FunctionPair::Function(func_id_, x);
    sum += fx;
  }
  double sredn = sum / static_cast<double>(point_count_);
  double integral = (b_ - a_) * sredn;
```
## 4. Схема распараллеливания
Распаралелливание алгоритма происходит по схеме распараллеливания по данным: 
- общее количество точек n делится между процессами;
- каждый процесс обрабатывает свою часть точек;
- с помощью операции `MPI_Reduce` локальные суммы складываются;
- итоговое значение рассылается всем процессам через `MPI_Bcast`.

Особенности:
- точки формируются на основе массива, распределяемого через `MPI_Scatterv`;
- используется детерминированная квазислучайная генерация;
- если число точек не делится нацело на число потоков, то первые процессы получают на одну точку больше.

## 5. Детали реализации

Структура проекта
|          Файл          |                 Суть                  |
|------------------------|---------------------------------------------|
| `common.hpp`           | Определение FuncType, входных и выходных типов задачи |
| `ops_seq.hpp/.cpp`     |         Последовательная реализация         |
| `ops_mpi.hpp/.cpp`     |                MPI-реализация               |
| `functional/main.cpp`  |             Функциональные тесты            |
| `performance/main.cpp` |       Тесты на производительность       |


Для всех вычислений используется класс, в котором определены значения самой функции, а также ее первообразной:
```cpp
FunctionPair::Function(func_id, x);
FunctionPair::Integral(func_id, x);
```

## 6. Экспериментальная среда
|  Параметр | Значение |
|------------|----------------------------------------------|
| CPU | Intel Core i3-6006U (2 ядра / 4 потока, 2.0 ГГц) |
| RAM | 8 GB |
|     ОС     | Windows 10 64-bit |
| Компилятор | MSVC (Visual Studio Build Tools) |
|     MPI    | Microsoft MPI 10.1 (mpiexec 10.1.12498.52) |



## 7. Результаты и обсуждение


### 7.1 Корректность
Функциональные тесты используют входные данные в виде кортежей `(a, b, n, func_id)`. Сама функция `f(x)` задается через `FunctionPair::Function(func_id, x);`. 

Ожидаемое значение интеграла вычисляется аналитически: `F(b) - F(a)`, где `F(x)` задается через `FunctionPair::Integral(func_id, x)`.

Из-за неустойчивой природы метода Монте-Карло результат считается корректным, если он попадает в доверительный интервал с учетом стандартного отклонения.
В тестах используется проверка на то, что абсолютная ошибка не превышает `10 * стандартное_отклонение (с минимальным порогом 1e-2)`.

Обе реализации (`SEQ`, `MPI`) прошли все тесты успешно.

### 7.2 Производительность

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| SEQ | 1 | 0.32 | 1 | N/A |
| MPI | 2 | 0.275 | 1.16 | 58.0% |
| MPI | 4 | 0.226  | 1.42 | 35.4% |


## 8. Заключение
В ходе работы:
- разработана последовательная версия алгоритма интегрирования методом Монте-Карло;
- разработана параллельная реализация с использованием MPI;
- проведены эксперементы корректности;
- рассчитаны характеристики ускорения и эффективности для распараллеленого алгоритма.

## 9. Источники
1. Сысоев А. В., Лекции по курсу «Параллельное программирование для кластерных систем».
2. Документация по курсу «Параллельное программирование», URL: https://learning-process.github.io/parallel_programming_course/ru/index.html
3. Репозиторий курса «Параллельное программирование», URL: https://github.com/learning-process/ppc-2025-processes-engineers
