# Проверка лексикографической упорядоченности двух строк

- Студент: Самойленко Илья Андреевич, группа 3823Б1ПР3
- Технология: SEQ|MPI
- Вариант: 26

## 1. Введение
Задача состоит в реализации последовательной и параллельной версий алгоритма, проверяющего лексикографическую упорядоченность двух строк относительно друг друга, а также создание функциональных тестов для проверки работоспособности алгоритма и тестов на производительность для сравнения последовательной и параллельной реализаций алгоритма.

## 2. Постановка задачи
Лексикографическое сравнение - это операция сравнения двух диапазонов.
Два диапазона сравниваются поэлементно. Первый несовпадающий элемент определяет, какой из диапазонов лексикографически меньше или больше другого. Если один диапазон является префиксом другого, то более короткий из них лексикографически меньше. Если два диапазона имеют эквивалентные элементы и одинаковую длину, то диапазоны лексикографически равны.
Пустой диапазон лексикографически меньше любого непустого диапазона.
Два пустых диапазона лексикографически равны.

В стандартной библиотеке C++ присутствует функция lexicographical_compare и решает примерно ту же задачу. В данной реализации она будет опорной как пример работы алгоритма.

Входные данные: пара строк
```cpp
using InType = std::pair<std::string, std::string>;
```
Выходные данные: bool (**true**, если первая строка лексикографически меньше второй или строки лексикографически равны, **false** иначе)
```cpp
using OutType = bool;
```

Ограничения:
- Длина любой из входных строк не может превышать максимальное значение типа unsigned int (4 294 967 295 символов)

## 3. Базовый алгоритм (Последовательный)
Два итератора (first1 и first2) проходят по строкам s1 и s2 в цикле до конца одной из строк. Если символ из первой строки меньше символа из второй, функция возвращает true, если больше - false. Если символы одинаковы, итераторы двигаются дальше. 
```cpp
for (; (first1 != last1) && (first2 != last2); ++first1, ++first2) {
    if (*first1 < *first2) {
      return true;
    }
    if (*first2 < *first1) {
      return false;
    }
  }
```

После цикла производятся проверки на равенство строк, в случае которого оба итератора дошли до конца своих строк, и на префикс, в случае которого итератор first1 достигнет конца своей строки, а first2 - нет.
```cpp
return ((first1 == last1) && (first2 == last2)) || ((first1 == last1) && (first2 != last2));
```

## 4. Схема распараллеливания
Общие данные (две строки) располагаются на всех процессах, и каждый процесс получает свой участок для сравнения.
```cpp
size_t min_len = std::min(str1.size(), str2.size());
size_t substr_size = (min_len + size - 1) / size;
size_t substr_start = rank * substr_size;
size_t substr_end = std::min(substr_start + substr_size, min_len);
```

Каждый процесс сравнивает символы только в своей части обеих строк, чтобы найти локальное различие символов, после чего с помощью MPI_Allreduce происходит обмен результатами между всеми процессами, чтобы найти минимальный глобальный индекс первого различия символов.
```cpp
unsigned int global_diff = 0;
MPI_Allreduce(&local_diff, &global_diff, 1, MPI_UNSIGNED, MPI_MIN, MPI_COMM_WORLD);
```

Процесс с рангом 0 принимает итоговое решение. Если не было найдено ни одного несовпадения, сравниваем длины строк (аналогично проверке на равенство и префикс из последовательной реализации). В противном случае сравниваем символы на позиции различия.

Синхронизация процессов обеспечивается с помощью MPI_Barrier.

## 5. Детали реализации
Структура кода
```
tasks/samoylenko_i_lex_order_check/
├───common
│   └───include
│           common.hpp // Определение типов данных
├───mpi
│   ├───include
│   │       ops_mpi.hpp
│   └───src
│           ops_mpi.cpp // Параллельная реализация
├───seq
│   ├───include
│   │       ops_seq.hpp
│   └───src
│           ops_seq.cpp // Последовательная реализация
└───tests
    ├───functional
    │       main.cpp // Функциональные тесты
    └───performance
            main.cpp // Тесты на производительность
```

Краевые случаи:
- Пустые строки
- Одинаковые строки
- Первая строка является префиксом второй
- Первая строка является постфиксом второй

Особенности использования памяти
- Процессы хранят полные строки локально, распределение данных не происходит.

## 6. Экспериментальная настройка
Аппаратное обеспечение и ОС:
- CPU: AMD Ryzen 5 2600X 
- ядра: 6
- потоки: 12
- RAM: 16 GB 
- OS: Ubuntu 24.04.2 LTS (DevContainer / Windows 10 22H2)

Набор инструментов: 
- Компилятор: g++ 13.3.0
- Тип сборки: Release
- MPI: OpenMPI 4.1.6

Переменные окружения:
 - OMPI_ALLOW_RUN_AS_ROOT=1
 - OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1

Данные:
Для функциональных тестов данные хранятся в виде строк внутри исходного кода тестов. Для тестов на производительность генерируется строка в 20 000 000 символов повторяющейся последовательности.

## 7. Результаты и обсуждение

### 7.1 Корректность
Функциональные тесты покрывают как обычные, так и краевые случаи. Все функциональные тесты проходят успешно.

### 7.2 Производительность

| Режим        | Процессы | Время, с | Ускорение | Эффективность |
|--------------|----------|----------|-----------|---------------|
| seq          | 1        | 1.08     | 1.00      | N/A           |
| mpi          | 1        | 1.35     | 0.8       | 80%           |
| mpi          | 2        | 0.75     | 1.44      | 72%           |
| mpi          | 4        | 0.46     | 2.35      | 58.75%        |

Ускорение = Время seq / Время mpi

Эффективность = Ускорение / Процессы * 100%

## 8. Заключение
Был реализован последовательный и параллельный алгоритмы лексикографического сравнения двух строк. Обе реализации прошли все тесты на функционал. MPI-версия масштабируется корректно (при увеличении доступных процессов в N раз ускорение также растёт в примерно N раз), но из-за расходов на коммуникацию между процессами и распределение данных между ними эффективность падает, а также добавляется дополнительная задержка, влияющая на итоговое время выполнения теста.

## 9. Источники
1. Документация алгоритма std::lexicographical_compare: https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare.html 
2. Материалы курса: https://learning-process.github.io/parallel_programming_course/ru/index.html
3. Документация Open MPI: https://www-lb.open-mpi.org/doc/

## Приложение
```cpp
  int rank = 0;
  int size = 0;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);

  size_t len1 = 0;
  size_t len2 = 0;
  const auto *input_ptr = (rank == 0) ? &GetInput() : nullptr;

  ExchangeLengths(rank, input_ptr, len1, len2);

  size_t min_len = std::min(len1, len2);
  size_t substr_size = (min_len + size - 1) / size;
  size_t substr_start = rank * substr_size;
  size_t substr_len = 0;
  if (substr_start < min_len) {
    substr_len = std::min(substr_size, min_len - substr_start);
  }

  std::string local_str1(substr_len, '\0');
  std::string local_str2(substr_len, '\0');

  ScatterData(rank, size, input_ptr, min_len, substr_size, substr_start, substr_len, local_str1, local_str2);

  unsigned int local_diff = FindLocalDifference(local_str1, local_str2, substr_start, min_len + 1);
  unsigned int global_diff = 0;

  MPI_Allreduce(&local_diff, &global_diff, 1, MPI_UNSIGNED, MPI_MIN, MPI_COMM_WORLD);

  int output = 0;
  if (rank == 0) {
    if (global_diff == static_cast<unsigned int>(min_len + 1)) {
      output = (len1 <= len2) ? 1 : 0;
    } else {
      output = (GetInput().first[global_diff] < GetInput().second[global_diff]) ? 1 : 0;
    }
  }

  MPI_Bcast(&output, 1, MPI_INT, 0, MPI_COMM_WORLD);
  GetOutput() = (output != 0);

  return true;
```