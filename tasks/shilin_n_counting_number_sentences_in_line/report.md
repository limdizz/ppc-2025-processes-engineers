# Подсчет числа предложений в строке

- **Студент**: Шилин Никита Дмитриевич, группа 3823Б1ПР1
- **Технологии**: SEQ | MPI
- **Вариант**: 25

## 1. Введение

Подсчет предложений в тексте - стандартная операция, используемая в системах системах машинного перевода и других приложениях и при анализе текста.
## 2. Постановка проблемы

**Цель работы:** реализовать эффективный алгоритм подсчета предложений в строке с использованием последовательного подхода (SEQ) и параллельного подхода (MPI), а также провести сравнительный анализ производительности обоих подходов.

## 2. Постановка задачи

**Формальная постановка:**

Для строки `S` размера `n` требуется определить количество предложений внутри строки.

**Входные данные:**
- Строка произвольной длины (тип `std::string`)
- Может содержать текст на любом языке
- Может быть пустой строкой

**Выходные данные:**
- Целое число (тип `int`) - количество предложений в строке

**Определение предложения:**

Предложение считается завершенным, если оно заканчивается одним из следующих знаков препинания:
- Точка (`.`)
- Восклицательный знак (`!`)
- Вопросительный знак (`?`)

**Особенности обработки:**
- Последовательные знаки препинания (например, `...`, `!!!`, `???`) считаются как одно окончание предложения
- Смешанная пунктуация (например, `.!?`) также считается как одно окончание предложения
- Строка без завершающих знаков препинания содержит 0 предложений
- Пустая строка содержит 0 предложений

**Ограничения:**
- Длина строки ограничена доступной памятью
- Алгоритм должен корректно обрабатывать Unicode-символы (UTF-8)
- Результаты последовательной и параллельной версий должны быть идентичны
- Параллельная реализация использует MPI и должна поддерживать различное количество процессов

## 3. Базовый алгоритм (последовательная версия)

### 3.1. Этапы выполнения задачи

**1. Валидация данных (`ValidationImpl`):**
- Проверка корректности начального состояния выходного значения (должно быть равно 0)

**2. Предобработка данных (`PreProcessingImpl`):**
- Инициализация счетчика предложений значением 0

**3. Вычисления (`RunImpl`):**
- Проход по строке от начала до конца
- Для каждого символа проверка, является ли он одним из знаков окончания предложения (`.`, `!`, `?`)
- При обнаружении знака препинания:
  - Увеличение счетчика предложений
  - Пропуск всех последующих последовательных знаков препинания

**4. Постобработка данных (`PostProcessingImpl`):**
- Задача не требует постобработки, поэтому данный этап пропускается

### 3.2. Алгоритм последовательной реализации

**Псевдокод:**

```
function RunImpl():
    input = GetInput()
    count = 0
    
    for i = 0 to input.length() - 1:
        ch = input[i]
        if ch == '.' OR ch == '!' OR ch == '?':
            count = count + 1
            // Пропустить все последующие знаки препинания
            while i + 1 < input.length() AND 
                  (input[i + 1] == '.' OR input[i + 1] == '!' OR input[i + 1] == '?'):
                i = i + 1
    
    GetOutput() = count
    return true
```

### 3.3. Сложность алгоритма

| Параметр                  | Значение |
|---------------------------|----------|
| Временная сложность       | O(n)     |
| Пространственная сложность| O(1)     |

где `n` - длина входной строки.

### 3.4. Код последовательной реализации

Реализация последовательной версии представлена в [Приложении №1](#приложение-1--реализация-последовательной-версии-алгоритма).

## 4. Схема параллельного алгоритма

Схема параллельного алгоритма происходит по **схеме распараллеливания по данным**: исходная строка разбивается на равные части между всеми процессами, каждый процесс обрабатывает свою часть независимо.

### 4.1. Распределение данных

**Алгоритм распределения:**

1. **Инициализация:**
   - Все процессы запускаются в одном коммуникаторе `MPI_COMM_WORLD`
   - Каждый процесс получает свой ранг (`rank`) и общее количество процессов (`size`)

2. **Передача входных данных:**
   - В конструкторе класса входные данные присваиваются только процессу с рангом 0 (главный процесс)
   - Процессы с рангом 1..N-1 не получают входные данные в конструкторе
   - В методе `RunImpl()` процесс 0 берет данные из `GetInput()`
   - Длина строки распространяется на все процессы через `MPI_Bcast`
   - Сама строка распространяется на все процессы через `MPI_Bcast`

3. **Вычисление границ сегментов:**
   - Базовый размер блока: `chunk_size = string_length / num_processes`
   - Остаток от деления: `remainder = string_length % num_processes`
   - Процессы с `rank < remainder` получают на 1 символ больше для балансировки нагрузки
   - Начало сегмента: `start_pos = rank * chunk_size + min(rank, remainder)`
   - Конец сегмента: `end_pos = start_pos + chunk_size + (rank < remainder ? 1 : 0)`

### 4.2. Топология коммуникаций

- **Линейная топология:** все процессы связаны через `MPI_COMM_WORLD`
- **Роль процессов:**
  - **Процесс 0 (главный):** получает входные данные, рассылает их всем процессам, собирает результаты
  - **Процессы 1..N-1:** получают данные, обрабатывают свой сегмент, отправляют локальный результат

### 4.3. Паттерны коммуникации

**Используемые MPI операции:**

1. **MPI_Bcast** - рассылка входных данных:
   ```cpp
   MPI_Bcast(&input_length, 1, MPI_INT, 0, MPI_COMM_WORLD);
   MPI_Bcast(input_str.data(), input_length, MPI_CHAR, 0, MPI_COMM_WORLD);
   ```
   - Тип операции: One-to-All
   - Режим работы: блокирующая операция
   - Объём передаваемых данных: длина строки (int) + сама строка (char array)

2. **MPI_Reduce** - сбор результатов:
   ```cpp
   MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
   ```
   - Тип операции: All-to-One с агрегацией результатов
   - Режим работы: блокирующая операция
   - Операция: суммирование (`MPI_SUM`)
   - Объём передаваемых данных: одно целое число с каждого процесса

3. **MPI_Bcast** - рассылка финального результата:
   ```cpp
   MPI_Bcast(&global_count, 1, MPI_INT, 0, MPI_COMM_WORLD);
   ```
   - Обеспечивает синхронизацию результата на всех процессах

### 4.4. Распределение вычислений

1. **Инициализация MPI** - получение ранга и числа процессов
2. **Распределение данных** - вычисление границ локального сегмента
3. **Обработка граничных случаев** - проверка границы между чанками для корректного подсчета последовательных знаков препинания
4. **Локальные вычисления** - подсчет предложений в назначенном сегменте
5. **Глобальная редукция** - объединение локальных счетчиков
6. **Синхронизация** - рассылка финального результата всем процессам

**Обработка граничных случаев:**

При разбиении строки на части по байтам, последовательность знаков препинания может быть разорвана на границе между чанками. Например, строка "abc..def" при разбиении так, что первая точка попадает в конец чанка rank 0, а вторая точка в начало чанка rank 1, может быть неправильно посчитана как два предложения вместо одного.

**Решение:**
- Каждый процесс (кроме rank 0) проверяет граничный символ слева от своего чанка (последний символ предыдущего чанка)
- Если первый символ текущего чанка - знак препинания, и левый граничный символ тоже знак препинания, то это продолжение последовательности из предыдущего чанка
- В этом случае все последовательные знаки препинания в начале чанка пропускаются (не считаются как новое предложение)
- Подсчет начинается с первого символа после последовательности знаков препинания

**Пример:**
- Строка: "abc..def"
- Rank 0: чанк "abc." - находит точку в позиции 3, считает 1 предложение
- Rank 1: чанк ".def" - левый граничный символ = '.', первый символ = '.', пропускает точку в начале, продолжает подсчет, не находит других знаков препинания, считает 0 предложений
- Итого: 1 + 0 = 1 предложение ✓

### 4.5. Псевдокод параллельной реализации

```cpp
//конструктор
constructor ShilinNCountingNumberSentencesInLineMPI(in):
    SetTypeOfTask(GetStaticTypeOfTask())
    rank = MPI_Comm_rank(MPI_COMM_WORLD)
    if rank == 0:
        GetInput() = in
    GetOutput() = 0

//основной метод
function RunImpl():
    rank = MPI_Comm_rank(MPI_COMM_WORLD)
    size = MPI_Comm_size(MPI_COMM_WORLD)
    
    if rank == 0:
        input_str = GetInput()
        input_length = input_str.length()
    
    MPI_Bcast(&input_length, 1, MPI_INT, 0, MPI_COMM_WORLD)
    
    if input_length == 0:
        GetOutput() = 0
        return true
    
    if rank != 0:
        input_str.resize(input_length)
    
    MPI_Bcast(input_str.data(), input_length, MPI_CHAR, 0, MPI_COMM_WORLD)
    
    chunk_size = input_length / size
    remainder = input_length % size
    start_pos = rank * chunk_size + min(rank, remainder)
    end_pos = start_pos + chunk_size + (rank < remainder ? 1 : 0)
    
    left_boundary_char = '\0'
    if start_pos > 0:
        left_boundary_char = input_str[start_pos - 1]
    
    is_punctuation(ch) = (ch == '.' OR ch == '!' OR ch == '?')
    
    local_count = 0
    
    if start_pos > 0 AND is_punctuation(left_boundary_char) AND 
       start_pos < input_length AND is_punctuation(input_str[start_pos]):
        i = start_pos
        while i < end_pos AND is_punctuation(input_str[i]):
            i = i + 1
        for i = i to end_pos - 1:
            ch = input_str[i]
            if is_punctuation(ch):
                local_count = local_count + 1
                while i + 1 < end_pos AND is_punctuation(input_str[i + 1]):
                    i = i + 1
    else:
        for i = start_pos to end_pos - 1:
            ch = input_str[i]
            if is_punctuation(ch):
                local_count = local_count + 1
                while i + 1 < end_pos AND is_punctuation(input_str[i + 1]):
                    i = i + 1
    
    global_count = 0
    MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD)
    
    MPI_Bcast(&global_count, 1, MPI_INT, 0, MPI_COMM_WORLD)
    
    GetOutput() = global_count
    
    return true
```

### 4.6. Схема работы программы

Схема представлена для 4 процессов:

```
┌─────────────────────────────────────┐
│  Входные данные (строка S)          │
└──────────┬──────────────────────────┘
           │ (rank 0 получает данные)
           ↓
┌──────────────────────────────────────────────────────────┐
│  Процесс 0:                                              │
│  - Получает входную строку                               │
│  - Вычисляет длину строки                                │
└──────────┬───────────────────────────────────────────────┘
           │ MPI_Bcast (длина + строка)
           ↓
┌──────────┴──────────┬──────────────┬─────────────────────┐
│  Процесс 0          │  Процесс 1   │  Процесс 2          │  Процесс 3
│  получает строку    │  получает    │  получает           │  получает
└──────────┬──────────┴──────────────┴─────────────────────┘
           │ (вычисление границ сегментов)
           ↓
┌──────────┴──────────┬──────────────┬─────────────────────┐
│  Сегмент [0, n/4)    │  [n/4, n/2)  │  [n/2, 3n/4)        │  [3n/4, n)
└──────────┬──────────┴──────────────┴─────────────────────┘
           │ (локальный подсчет предложений)
           ↓
┌──────────┴──────────┬──────────────┬─────────────────────┐
│  local_count(0)      │  local_count(1)│  local_count(2)   │  local_count(3)
└──────────┬──────────┴──────────────┴─────────────────────┘
           │ MPI_Reduce (суммирование)
           ↓
┌─────────────────────────────────────┐
│  Процесс 0 получает global_count    │
└──────────┬──────────────────────────┘
           │ MPI_Bcast (рассылка результата)
           ↓
┌──────────────────────────────────────────────────────────┐
│   Все процессы получают итоговое значение                │
│   Сохранение: GetOutput() = global_count                 │
└──────────────────────────────────────────────────────────┘
```

Реализация параллельной версии представлена в [Приложении №2](#приложение-2--реализация-параллельной-версии-алгоритма).

## 5. Детали реализации

### 5.1. Структура кода

**Файловая структура:**

```
shilin_n_counting_number_sentences_in_line/
├── common/
│   └── include/common.hpp          - определения типов данных
├── seq/
│   ├── include/ops_seq.hpp         - заголовочный файл последовательной версии
│   └── src/ops_seq.cpp             - исходный код последовательной версии
├── mpi/
│   ├── include/ops_mpi.hpp          - заголовочный файл MPI-реализации
│   └── src/ops_mpi.cpp             - исходный код параллельной версии
└── tests/
    ├── functional/
    │   └── main.cpp                - функциональные тесты
    └── performance/
        └── main.cpp                - тесты производительности
```

**Ключевые классы реализации:**

- `ShilinNCountingNumberSentencesInLineSEQ` - класс последовательной реализации алгоритма
- `ShilinNCountingNumberSentencesInLineMPI` - класс параллельной реализации алгоритма

**Интерфейс методов реализации:**

- `RunImpl()` - основной метод, содержащий реализацию алгоритма
- `ValidationImpl()` - проверка корректности начального состояния и входных параметров
- `PreProcessingImpl()` - подготовительные операции с входными данными
- `PostProcessingImpl()` - завершающая обработка результатов вычислений

### 5.2. Особенности реализации и обработка граничных случаев

**Обработка данных:**

- **Пустая строка:** возвращает 0 предложений
- **Строка без знаков препинания:** возвращает 0 предложений
- **Множественная пунктуация:** последовательные знаки (`.`, `!`, `?`) считаются как одно окончание предложения
- **Смешанная пунктуация:** комбинации знаков (`.!?`) также считаются как одно окончание предложения
- **Короткие строки:** эффективно обрабатываются в SEQ режиме

**Граничные случаи:**

```cpp
count("") = 0                    //пустая строка
count("Hello world") = 0         //нет знаков препинания
count("Hello!") = 1              //одно предложение
count("Hello! How are you?") = 2 //два предложения
count("Hello...") = 1            //множественная пунктуация
count("Hello.!?") = 1            //смешанная пунктуация
count("A.") = 1                 //один символ с точкой
count(".!?") = 1                //смешанная пунктуация в одном месте
count("!?.") = 1                //смешанная пунктуация в обратном порядке
count("Hello . World !") = 2    //пробелы вокруг знаков препинания
count("A.B.C") = 2              //минимальные предложения (2 точки, последнее без точки)
count("abc..def.") = 2          //последовательные точки на границе чанка (2 отдельные точки)
count("abc...def.") = 2         //многоточие на границе чанка (первая и последняя точки)
count("abc!!!def.") = 2         //многоточие и точка на границе
count("abc.!?def.") = 2         //смешанная пунктуация на границе
```

### 5.3. Использование памяти

- **Последовательная версия:** `O(1)` дополнительной памяти - используется только счетчик
- **Параллельная версия:** `O(n × P)` - каждый из `P` процессов хранит полную копию строки длины `n`
- **Обмен данными:** `O(P)` - для операций `MPI_Bcast` и `MPI_Reduce` передается одно целое число на процесс

**Примечание:** В текущей реализации вся строка копируется на каждый процесс для упрощения логики. Альтернатива с распределенной памятью возможна, но усложняет обработку границ между сегментами.

## 6. Экспериментальная установка

### 6.1. Аппаратное обеспечение

| Параметр | Значение                                            |
|----------|-----------------------------------------------------|
| CPU      | Apple M4 Pro (10 performance cores + 4 efficiency cores) |
| RAM      | 24 GB                                               |
| OS       | macOS Tahoe 26.0                                    |

### 6.2. Программное обеспечение

| Параметр   | Значение                    |
|------------|----------------------------|
| Компилятор | AppleClang 17.0.0.17000013 |
| MPI        | Open MPI 5.0.8             |
| Сборка     | Release                    |
| CMake      | 3.27.3                      |

### 6.3. Переменные окружения

```bash
export PPC_NUM_PROC=4
export OMPI_MCA_pmix_tool_enable=0
```

### 6.4. Тестовые данные

**Функциональные тесты:**
- 15 различных входных строк с известными результатами
- Каждая строка тестируется в SEQ и MPI режимах (итого 30 тестов)
- Тестовые случаи включают:
  - Пустые строки
  - Строки без предложений
  - Одно предложение
  - Множественные предложения (до 10)
  - Различные знаки препинания
  - Множественная пунктуация
  - Граничные случаи

**Тесты производительности:**
- Строка из 1,000,000 случайно сгенерированных предложений (~25,000,000 символов)
- Параметры генерации:
  - Каждое предложение содержит 3-10 слов
  - Каждое слово содержит 3-8 случайных букв (a-z)
  - Предложения завершаются одним из трех знаков: `.`, `!`, `?`
  - Используется `std::random_device` для генерации случайных данных

Реализация генерации тестовых данных представлена в [Приложении №3](#приложение-3--генерация-тестовых-данных-для-тестов-производительности).

## 7. Результаты и обсуждение

### 7.1. Корректность

Корректность реализации проверена следующими способами:

**1. Функциональные тесты (30 тестов):**
- 15 различных входных строк
- Каждая строка тестируется в SEQ и MPI режимах (итого 30 тестов)
- Все тесты пройдены успешно

**2. Тестовые случаи включают:**
- Пустые строки
- Строки без предложений
- Одно предложение
- Множественные предложения (до 10)
- Различные знаки препинания
- Множественная пунктуация
- Граничные случаи

**3. Сравнение результатов:**
- Результаты SEQ и MPI версий идентичны для всех тестовых случаев
- MPI версия с разным количеством процессов (1, 2, 4) дает примерно одинаковые результаты

**Пример проверки:**
```
Input: "Hello! How are you?"
Expected: 2
SEQ result: 2 ✓
MPI result (4 processes): 2 ✓
```

**Результаты проверки корректности:**
- Все 30 функциональных тестов пройдены успешно
- Результаты SEQ и MPI реализаций полностью совпадают
- Обработка всех граничных случаев корректна

### 7.2. Производительность

**Методология измерений:**
- Каждый тест запускается 5 раз (default в PipelinePerfTest)
- Берется среднее время выполнения
- Speedup = T_seq / T_parallel
- Efficiency = Speedup / N_processes × 100%

**Параметры тестирования:**
- **Данные:** строка из 1,000,000 предложений (~25,000,000 символов)
- **Метрики:**
  - Абсолютное время выполнения
  - Ускорение относительно последовательной версии
  - Эффективность параллелизации
- **Сценарии измерения:**
  - **Полный цикл (pipeline)** - измерение времени выполнения всей программы (`Validation`, `PreProcessing`, `RunImpl`, `PostProcessing`)
  - **Только вычислительная часть (task_run)** - измерение времени только этапа выполнения алгоритма (`RunImpl`)

**Результаты полного цикла выполнения (pipeline):**

| Режим        | Процессы | Время, с | Ускорение | Эффективность |
|--------------|----------|----------|-----------|---------------|
| seq          | 1        | 0.0154   | 1.000     | N/A           |
| mpi pipeline | 1        | 0.0158   | 0.974     | 97.4%         |
| mpi pipeline | 2        | 0.0082   | 1.878     | 93.9%         |
| mpi pipeline | 4        | 0.0052   | 2.962     | 74.0%         |


**Результаты вычислительной части (task_run):**

| Режим        | Процессы | Время, с | Ускорение | Эффективность |
|--------------|----------|----------|-----------|---------------|
| seq          | 1        | 0.0154   | 1.000     | N/A           |
| mpi task_run | 4        | 0.0040   | 3.850     | 96.3%         |

**Анализ результатов:**

1. **Производительность:**
   - SEQ версия: ~0.015 секунды (достаточно для измерений)
   - MPI с 1 процессом: практически идентична SEQ (overhead ~3%)
   - MPI с 2 процессами: отличное масштабирование (94% эффективности)
   - MPI с 4 процессами: хорошее ускорение (2.96×), но снижение эффективности из-за коммуникационных издержек

2. **Эффективность параллелизации:**
   - На 2 процессах достигается высокая эффективность 94%
   - На 4 процессах эффективность снижается до 74% из-за роста коммуникационных затрат
   - task_run режим показывает лучшую эффективность (96.3%) чем pipeline (74.0%)

3. **Ограничения масштабируемости:**
   - Необходимость хранения полных копий строк в каждом процессе создает повышенные требования к оперативной памяти
   - Из-за затрат на коммуникацию между процессами эффективность снижается при увеличении числа процессов

## 8. Выводы

### 8.1. Достигнутые результаты

1. **Корректность реализации:**
   - Успешно разработаны последовательная и параллельная MPI-реализации алгоритма подсчета предложений в строке
   - Проведенное функциональное тестирование подтвердило корректность работы обеих версий на различных наборах данных
   - Результаты SEQ и MPI версий полностью совпадают

2. **Эффективность параллелизации:**
   - На 2 процессах достигнуто близкое к линейному ускорение (1.88×) с высокой эффективностью 94%
   - При увеличении числа процессов до 4 сохраняется значительное ускорение (2.96×), однако эффективность снижается до 74%
   - task_run режим демонстрирует лучшую эффективность (96.3%) по сравнению с полным циклом

3. **Эффективное распараллеливание:**
   - Алгоритм хорошо масштабируется с ростом числа процессов до 4
   - Схема распределения данных обеспечивает балансировку нагрузки
   - Использование единственной коллективной операции `MPI_Reduce` минимизирует коммуникационные затраты

### 8.2. Ограничения и проблемы

1. **Коммуникационные накладные расходы:**
   - Полный цикл (pipeline) показывает снижение эффективности при увеличении числа процессов
   - Необходимость рассылки полной строки на все процессы создает значительные коммуникационные затраты

2. **Ограничения масштабируемости:**
   - Эффективность может снижаться при очень большом числе процессов
   - Для эффективного использования MPI нужны значительно большие объемы данных

3. **Требования к памяти:**
   - Для очень больших данных требуется значительный объем RAM (каждый процесс хранит полную копию строки)

### 8.3. Рекомендации

- Для строк < 1 млн символов использовать SEQ версию
- Для очень больших текстов (> 10 млн символов) или множественных строк - использовать MPI версию
- Оптимальное количество процессов для данной задачи: 2-4 процесса

## 9. Источники

1. Сысоев А. В. "Коллективные и парные взаимодействия" // Лекции по дисциплине «Параллельное программирование для кластерных систем». — 2025.

2. Документация по курсу «Параллельное программирование» // Parallel Programming Course URL: https://learning-process.github.io/parallel_programming_course/ru/index.html (дата обращения: 12.11.2025).

3. MPI Forum. MPI: A Message-Passing Interface Standard, Version 4.0. 2021. URL: https://www.mpi-forum.org/docs/ (дата обращения: 12.11.2025).

4. Microsoft. Справочник по MPI. — 2024. URL: https://learn.microsoft.com/ru-ru/message-passing-interface/mpi-reference (дата обращения: 12.11.2025).

## Приложения

### Приложение №1. Реализация последовательной версии алгоритма

**Файл:** `seq/src/ops_seq.cpp`

```cpp
bool ShilinNCountingNumberSentencesInLineSEQ::RunImpl() {
  const std::string &input = GetInput();
  int count = 0;

  for (size_t i = 0; i < input.length(); ++i) {
    char ch = input[i];
    if (ch == '.' || ch == '!' || ch == '?') {
      count++;
      while (i + 1 < input.length() && 
             (input[i + 1] == '.' || input[i + 1] == '!' || input[i + 1] == '?')) {
        ++i;
      }
    }
  }

  GetOutput() = count;
  return true;
}
```

### Приложение №2. Реализация параллельной версии алгоритма

**Файл:** `mpi/src/ops_mpi.cpp`

**Конструктор:**
```cpp
ShilinNCountingNumberSentencesInLineMPI::ShilinNCountingNumberSentencesInLineMPI(const InType &in) {
  SetTypeOfTask(GetStaticTypeOfTask());
  int rank = 0;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  if (rank == 0) {
    GetInput() = in;
  }
  GetOutput() = 0;
}
```

**Основной метод:**
```cpp
bool ShilinNCountingNumberSentencesInLineMPI::RunImpl() {
  int rank = 0;
  int size = 0;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);

  std::string input_str;
  int input_length = 0;

  if (rank == 0) {
    input_str = GetInput();
    input_length = static_cast<int>(input_str.length());
  }

  MPI_Bcast(&input_length, 1, MPI_INT, 0, MPI_COMM_WORLD);

  if (input_length == 0) {
    if (rank == 0) {
      GetOutput() = 0;
    }
    return true;
  }

  if (rank != 0) {
    input_str.resize(input_length);
  }

  MPI_Bcast(input_str.data(), input_length, MPI_CHAR, 0, MPI_COMM_WORLD);

  int chunk_size = input_length / size;
  int remainder = input_length % size;

  int start_pos = (rank * chunk_size) + std::min(rank, remainder);
  int end_pos = start_pos + chunk_size + (rank < remainder ? 1 : 0);

  char left_boundary_char = '\0';
  if (start_pos > 0) {
    left_boundary_char = input_str[start_pos - 1];
  }

  auto is_punctuation = [](char c) { return c == '.' || c == '!' || c == '?'; };

  int local_count = 0;

  if (start_pos > 0 && is_punctuation(left_boundary_char) && 
      start_pos < input_length && is_punctuation(input_str[start_pos])) {

    int i = start_pos;
    while (i < end_pos && is_punctuation(input_str[i])) {
      ++i;
    }

    for (; i < end_pos; ++i) {
      char ch = input_str[i];
      if (is_punctuation(ch)) {
        local_count++;
        while (i + 1 < end_pos && is_punctuation(input_str[i + 1])) {
          ++i;
        }
      }
    }
  } else {

    for (int i = start_pos; i < end_pos; ++i) {
      char ch = input_str[i];
      if (is_punctuation(ch)) {
        local_count++;
        while (i + 1 < end_pos && is_punctuation(input_str[i + 1])) {
          ++i;
        }
      }
    }
  }

  int global_count = 0;
  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Bcast(&global_count, 1, MPI_INT, 0, MPI_COMM_WORLD);

  GetOutput() = global_count;
  return true;
}
```

### Приложение №3. Генерация тестовых данных для тестов производительности

**Файл:** `tests/performance/main.cpp`

```cpp
void SetUp() override {
  const int num_sentences = 1000000;
  input_data_.clear();

  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_int_distribution<> word_count_dist(3, 10);
  std::uniform_int_distribution<> word_len_dist(3, 8);
  std::uniform_int_distribution<> punct_dist(0, 2);

  expected_output_ = 0;

  for (int i = 0; i < num_sentences; ++i) {
    int word_count = word_count_dist(gen);
    for (int j = 0; j < word_count; ++j) {
      int word_len = word_len_dist(gen);
      for (int k = 0; k < word_len; ++k) {
        input_data_ += static_cast<char>('a' + (gen() % 26));
      }
      if (j < word_count - 1) {
        input_data_ += ' ';
      }
    }

    constexpr std::array<char, 3> kPunctuation = {'.', '!', '?'};
    input_data_ += kPunctuation.at(static_cast<size_t>(punct_dist(gen)));
    input_data_ += ' ';
    expected_output_++;
  }
}
```
